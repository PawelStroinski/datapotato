(ns short-sweet
  (:require
   [clojure.spec.alpha :as s]
   [clojure.spec.gen.alpha :as gen]
   [donut.datapotato.core :as dc]))

;;-------*****--------
;; Begin example setup
;;-------*****--------

;; ---
;; Define specs for our domain entities

;; The ::id should be a positive int, and to generate it we increment
;; the number stored in `id-seq`. This ensures unique ids and produces
;; values that are easier for humans to understand
(def id-seq (atom 0))
(s/def ::id (s/with-gen pos-int? #(gen/fmap (fn [_] (swap! id-seq inc)) (gen/return nil))))
(s/def ::not-empty-string (s/and string? not-empty #(< (count %) 10)))

(s/def ::username ::not-empty-string)
(s/def ::user (s/keys :req-un [::id ::username]))

(s/def ::created-by-id ::id)
(s/def ::content ::not-empty-string)
(s/def ::post (s/keys :req-un [::id ::created-by-id ::content]))

(s/def ::post-id ::id)
(s/def ::like (s/keys :req-un [::id ::post-id ::created-by-id]))

;; ---
;; The schema defines datapotato `ent-types`, which roughly
;; correspond to db tables. It also defines the `:spec` for generting
;; ents of that type, and defines ent `relations` that specify how
;; ents reference each other
(def schema
  {:user {:prefix   :u
          :generate {:schema ::user}}
   :post {:prefix    :p
          :generate  {:schema ::post}
          :relations {:created-by-id [:user :id]}}
   :like {:prefix      :l
          :generate    {:schema ::like}
          :relations   {:post-id       [:post :id]
                        :created-by-id [:user :id]}
          :constraints {:created-by-id #{:uniq}}}})

;; Our "db" is a vector of inserted records we can use to show that
;; entities are inserted in the correct order
(def mock-db (atom []))

(defn insert-in-atom
  "Simulates inserting records in a db by conjing values onto an atom. ent-type is
  `:user`, `:post`, or `:like`, corresponding to the keys in the schema.
  `visit-val` is the map generated by clojure.spec"
  [_ent-db {:keys [ent-type visit-val]}]
  (swap! mock-db conj [ent-type visit-val]))

(def insert-visiting-fn
  (dc/wrap-incremental-insert-visiting-fn :generate insert-in-atom))

(def ent-db
  {:schema   schema
   :generate {:generator (comp gen/generate s/gen)}})

(defn insert
  [query]
  (reset! id-seq 0)
  (reset! mock-db [])
  (-> ent-db
      (dc/generate query)
      (dc/visit-ents-once :inserted-data insert-visiting-fn))
  ;; normally you'd return the expression above, but return nil for
  ;; the example to not produce overwhelming output
  nil)

;;-------*****--------
;; Begin snippets to try in REPL
;;-------*****--------

;; Return a map of user entities and their spec-generated data
(dc/generate-attr-map ent-db {:user [{:num 3}]})

;; You can specify a username and id
(dc/generate-attr-map ent-db {:user [{:num      1
                                      :generate {:username "Meeghan"
                                                 :id       100}}]})

;; Generating a post generates the user the post belongs to, with
;; foreign keys correct
(dc/generate-attr-map ent-db {:post [{:num 1}]})

;; Generating a like also generates a post and user
(dc/generate-attr-map ent-db {:like [{:num 1}]})

;; The `insert` function shows that records are inserted into the
;; simulate "database" (`mock-db`) in correct dependency order:
(insert {:like [{:num 1}]})
@mock-db
